# yovo 0.0.1, libYaml 0.1.2                                  -*- mode: text -*-
%YAML 1.1
%TAG ! tag:oblong.com,2009:slaw/
--- !!omap
- 'null': '[no slaw -- NULL]'
- nil: 'slaw[xxx]: NIL.'
- 'false': 'slaw[xxx]: BOOLEAN: false'
- 'true': 'slaw[xxx]: BOOLEAN: true'
- string: 'slaw[xxx]: STR(21): "Satan eats Cheez Whiz"'
- empty-list: |-
    slaw[xxx]: LIST (0 elems): {
     }
- empty-map: |-
    slaw[xxx]: MAP (0 elems): {
     }
- hm-map: |-
    slaw[xxx]: MAP (12 elems): {
     1: slaw[xxx]: CONS:
     1:  L: slaw[xxx]: STR(7): "mortals"
     1:  R: slaw[xxx]: STR(7): "foolish"
     2: slaw[xxx]: CONS:
     2:  L: slaw[xxx]: STR(6): "pallor"
     2:  R: slaw[xxx]: STR(10): "cadaverous"
     3: slaw[xxx]: CONS:
     3:  L: slaw[xxx]: STR(4): "aura"
     3:  R: slaw[xxx]: STR(10): "foreboding"
     4: slaw[xxx]: CONS:
     4:  L: slaw[xxx]: STR(13): "metamorphosis"
     4:  R: slaw[xxx]: STR(11): "disquieting"
     5: slaw[xxx]: CONS:
     5:  L: slaw[xxx]: STR(11): "observation"
     5:  R: slaw[xxx]: STR(9): "dismaying"
     6: slaw[xxx]: CONS:
     6:  L: slaw[xxx]: STR(2): "no"
     6:  R: slaw[xxx]: LIST (2 elems): {
     6:  R:  1: slaw[xxx]: STR(7): "windows"
     6:  R:  2: slaw[xxx]: STR(5): "doors"
     6:  R:  }
     7: slaw[xxx]: CONS:
     7:  L: slaw[xxx]: STR(9): "challenge"
     7:  R: slaw[xxx]: STR(8): "chilling"
     8: slaw[xxx]: CONS:
     8:  L: slaw[xxx]: STR(3): "way"
     8:  R: slaw[xxx]: LIST (2 elems): {
     8:  R:  1: slaw[xxx]: STR(3): "out"
     8:  R:  2: slaw[xxx]: STR(2): "my"
     8:  R:  }
     9: slaw[xxx]: CONS:
     9:  L: slaw[xxx]: STR(8): "frighten"
     9:  R: slaw[xxx]: STR(11): "prematurely"
     10: slaw[xxx]: CONS:
     10:  L: slaw[xxx]: STR(6): "haunts"
     10:  R: slaw[xxx]: INT16 = 999
     11: slaw[xxx]: CONS:
     11:  L: slaw[xxx]: LIST (2 elems): {
     11:  L:  1: slaw[xxx]: STR(4): "room"
     11:  L:  2: slaw[xxx]: STR(3): "for"
     11:  L:  }
     11:  R: slaw[xxx]: UNT32 = 1000
     12: slaw[xxx]: CONS:
     12:  L: slaw[xxx]: STR(11): "volunteers?"
     12:  R: slaw[xxx]: BOOLEAN: false
     }
- int32: 'slaw[xxx]: INT32 = 0'
- int32[0]: 'slaw[xxx]: INT32/A(0) = []'
- int32[1]: 'slaw[xxx]: INT32/A(1) = [0]'
- int32[3]: 'slaw[xxx]: INT32/A(3) = [0 ; 0 ; 0]'
- unt32: 'slaw[xxx]: UNT32 = 0'
- unt32[0]: 'slaw[xxx]: UNT32/A(0) = []'
- unt32[1]: 'slaw[xxx]: UNT32/A(1) = [0]'
- unt32[3]: 'slaw[xxx]: UNT32/A(3) = [0 ; 0 ; 0]'
- int64: 'slaw[xxx]: INT64 = 0'
- int64[0]: 'slaw[xxx]: INT64/A(0) = []'
- int64[1]: 'slaw[xxx]: INT64/A(1) = [0]'
- int64[3]: 'slaw[xxx]: INT64/A(3) = [0 ; 0 ; 0]'
- unt64: 'slaw[xxx]: UNT64 = 0'
- unt64[0]: 'slaw[xxx]: UNT64/A(0) = []'
- unt64[1]: 'slaw[xxx]: UNT64/A(1) = [0]'
- unt64[3]: 'slaw[xxx]: UNT64/A(3) = [0 ; 0 ; 0]'
- float32: 'slaw[xxx]: FLOAT32 = 0.000000'
- float32[0]: 'slaw[xxx]: FLOAT32/A(0) = []'
- float32[1]: 'slaw[xxx]: FLOAT32/A(1) = [0.000000]'
- float32[3]: 'slaw[xxx]: FLOAT32/A(3) = [0.000000 ; 0.000000 ; 0.000000]'
- float64: 'slaw[xxx]: FLOAT64 = 0.000000'
- float64[0]: 'slaw[xxx]: FLOAT64/A(0) = []'
- float64[1]: 'slaw[xxx]: FLOAT64/A(1) = [0.000000]'
- float64[3]: 'slaw[xxx]: FLOAT64/A(3) = [0.000000 ; 0.000000 ; 0.000000]'
- int8: 'slaw[xxx]: INT8 = 0'
- int8[0]: 'slaw[xxx]: INT8/A(0) = []'
- int8[1]: 'slaw[xxx]: INT8/A(1) = [0]'
- int8[3]: 'slaw[xxx]: INT8/A(3) = [0 ; 0 ; 0]'
- unt8: 'slaw[xxx]: UNT8 = 0'
- unt8[0]: 'slaw[xxx]: UNT8/A(0) = []'
- unt8[1]: 'slaw[xxx]: UNT8/A(1) = [0]'
- unt8[3]: 'slaw[xxx]: UNT8/A(3) = [0 ; 0 ; 0]'
- int16: 'slaw[xxx]: INT16 = 0'
- int16[0]: 'slaw[xxx]: INT16/A(0) = []'
- int16[1]: 'slaw[xxx]: INT16/A(1) = [0]'
- int16[3]: 'slaw[xxx]: INT16/A(3) = [0 ; 0 ; 0]'
- unt16: 'slaw[xxx]: UNT16 = 0'
- unt16[0]: 'slaw[xxx]: UNT16/A(0) = []'
- unt16[1]: 'slaw[xxx]: UNT16/A(1) = [0]'
- unt16[3]: 'slaw[xxx]: UNT16/A(3) = [0 ; 0 ; 0]'
- int32c: 'slaw[xxx]: INT32C = 0 + j0'
- int32c[0]: 'slaw[xxx]: INT32C/A(0) = []'
- int32c[1]: 'slaw[xxx]: INT32C/A(1) = [0 + j0]'
- int32c[3]: 'slaw[xxx]: INT32C/A(3) = [0 + j0 ; 0 + j0 ; 0 + j0]'
- unt32c: 'slaw[xxx]: UNT32C = 0 + j0'
- unt32c[0]: 'slaw[xxx]: UNT32C/A(0) = []'
- unt32c[1]: 'slaw[xxx]: UNT32C/A(1) = [0 + j0]'
- unt32c[3]: 'slaw[xxx]: UNT32C/A(3) = [0 + j0 ; 0 + j0 ; 0 + j0]'
- int64c: 'slaw[xxx]: INT64C = 0 + j0'
- int64c[0]: 'slaw[xxx]: INT64C/A(0) = []'
- int64c[1]: 'slaw[xxx]: INT64C/A(1) = [0 + j0]'
- int64c[3]: 'slaw[xxx]: INT64C/A(3) = [0 + j0 ; 0 + j0 ; 0 + j0]'
- unt64c: 'slaw[xxx]: UNT64C = 0 + j0'
- unt64c[0]: 'slaw[xxx]: UNT64C/A(0) = []'
- unt64c[1]: 'slaw[xxx]: UNT64C/A(1) = [0 + j0]'
- unt64c[3]: 'slaw[xxx]: UNT64C/A(3) = [0 + j0 ; 0 + j0 ; 0 + j0]'
- float32c: 'slaw[xxx]: FLOAT32C = 0.000000 + j0.000000'
- float32c[0]: 'slaw[xxx]: FLOAT32C/A(0) = []'
- float32c[1]: 'slaw[xxx]: FLOAT32C/A(1) = [0.000000 + j0.000000]'
- float32c[3]: 'slaw[xxx]: FLOAT32C/A(3) = [0.000000 + j0.000000 ; 0.000000
    + j0.000000 ; 0.000000 + j0.000000]'
- float64c: 'slaw[xxx]: FLOAT64C = 0.000000 + j0.000000'
- float64c[0]: 'slaw[xxx]: FLOAT64C/A(0) = []'
- float64c[1]: 'slaw[xxx]: FLOAT64C/A(1) = [0.000000 + j0.000000]'
- float64c[3]: 'slaw[xxx]: FLOAT64C/A(3) = [0.000000 + j0.000000 ; 0.000000
    + j0.000000 ; 0.000000 + j0.000000]'
- int8c: 'slaw[xxx]: INT8C = 0 + j0'
- int8c[0]: 'slaw[xxx]: INT8C/A(0) = []'
- int8c[1]: 'slaw[xxx]: INT8C/A(1) = [0 + j0]'
- int8c[3]: 'slaw[xxx]: INT8C/A(3) = [0 + j0 ; 0 + j0 ; 0 + j0]'
- unt8c: 'slaw[xxx]: UNT8C = 0 + j0'
- unt8c[0]: 'slaw[xxx]: UNT8C/A(0) = []'
- unt8c[1]: 'slaw[xxx]: UNT8C/A(1) = [0 + j0]'
- unt8c[3]: 'slaw[xxx]: UNT8C/A(3) = [0 + j0 ; 0 + j0 ; 0 + j0]'
- int16c: 'slaw[xxx]: INT16C = 0 + j0'
- int16c[0]: 'slaw[xxx]: INT16C/A(0) = []'
- int16c[1]: 'slaw[xxx]: INT16C/A(1) = [0 + j0]'
- int16c[3]: 'slaw[xxx]: INT16C/A(3) = [0 + j0 ; 0 + j0 ; 0 + j0]'
- unt16c: 'slaw[xxx]: UNT16C = 0 + j0'
- unt16c[0]: 'slaw[xxx]: UNT16C/A(0) = []'
- unt16c[1]: 'slaw[xxx]: UNT16C/A(1) = [0 + j0]'
- unt16c[3]: 'slaw[xxx]: UNT16C/A(3) = [0 + j0 ; 0 + j0 ; 0 + j0]'
- v2int32: 'slaw[xxx]: V2INT32 = (0, 0)'
- v2int32[0]: 'slaw[xxx]: V2INT32/A(0) = []'
- v2int32[1]: 'slaw[xxx]: V2INT32/A(1) = [(0, 0)]'
- v2int32[3]: 'slaw[xxx]: V2INT32/A(3) = [(0, 0) ; (0, 0) ; (0, 0)]'
- v2unt32: 'slaw[xxx]: V2UNT32 = (0, 0)'
- v2unt32[0]: 'slaw[xxx]: V2UNT32/A(0) = []'
- v2unt32[1]: 'slaw[xxx]: V2UNT32/A(1) = [(0, 0)]'
- v2unt32[3]: 'slaw[xxx]: V2UNT32/A(3) = [(0, 0) ; (0, 0) ; (0, 0)]'
- v2int64: 'slaw[xxx]: V2INT64 = (0, 0)'
- v2int64[0]: 'slaw[xxx]: V2INT64/A(0) = []'
- v2int64[1]: 'slaw[xxx]: V2INT64/A(1) = [(0, 0)]'
- v2int64[3]: 'slaw[xxx]: V2INT64/A(3) = [(0, 0) ; (0, 0) ; (0, 0)]'
- v2unt64: 'slaw[xxx]: V2UNT64 = (0, 0)'
- v2unt64[0]: 'slaw[xxx]: V2UNT64/A(0) = []'
- v2unt64[1]: 'slaw[xxx]: V2UNT64/A(1) = [(0, 0)]'
- v2unt64[3]: 'slaw[xxx]: V2UNT64/A(3) = [(0, 0) ; (0, 0) ; (0, 0)]'
- v2float32: 'slaw[xxx]: V2FLOAT32 = (0.000000, 0.000000)'
- v2float32[0]: 'slaw[xxx]: V2FLOAT32/A(0) = []'
- v2float32[1]: 'slaw[xxx]: V2FLOAT32/A(1) = [(0.000000, 0.000000)]'
- v2float32[3]: 'slaw[xxx]: V2FLOAT32/A(3) = [(0.000000, 0.000000) ; (0.000000,
    0.000000) ; (0.000000, 0.000000)]'
- v2float64: 'slaw[xxx]: V2FLOAT64 = (0.000000, 0.000000)'
- v2float64[0]: 'slaw[xxx]: V2FLOAT64/A(0) = []'
- v2float64[1]: 'slaw[xxx]: V2FLOAT64/A(1) = [(0.000000, 0.000000)]'
- v2float64[3]: 'slaw[xxx]: V2FLOAT64/A(3) = [(0.000000, 0.000000) ; (0.000000,
    0.000000) ; (0.000000, 0.000000)]'
- v2int8: 'slaw[xxx]: V2INT8 = (0, 0)'
- v2int8[0]: 'slaw[xxx]: V2INT8/A(0) = []'
- v2int8[1]: 'slaw[xxx]: V2INT8/A(1) = [(0, 0)]'
- v2int8[3]: 'slaw[xxx]: V2INT8/A(3) = [(0, 0) ; (0, 0) ; (0, 0)]'
- v2unt8: 'slaw[xxx]: V2UNT8 = (0, 0)'
- v2unt8[0]: 'slaw[xxx]: V2UNT8/A(0) = []'
- v2unt8[1]: 'slaw[xxx]: V2UNT8/A(1) = [(0, 0)]'
- v2unt8[3]: 'slaw[xxx]: V2UNT8/A(3) = [(0, 0) ; (0, 0) ; (0, 0)]'
- v2int16: 'slaw[xxx]: V2INT16 = (0, 0)'
- v2int16[0]: 'slaw[xxx]: V2INT16/A(0) = []'
- v2int16[1]: 'slaw[xxx]: V2INT16/A(1) = [(0, 0)]'
- v2int16[3]: 'slaw[xxx]: V2INT16/A(3) = [(0, 0) ; (0, 0) ; (0, 0)]'
- v2unt16: 'slaw[xxx]: V2UNT16 = (0, 0)'
- v2unt16[0]: 'slaw[xxx]: V2UNT16/A(0) = []'
- v2unt16[1]: 'slaw[xxx]: V2UNT16/A(1) = [(0, 0)]'
- v2unt16[3]: 'slaw[xxx]: V2UNT16/A(3) = [(0, 0) ; (0, 0) ; (0, 0)]'
- v3int32: 'slaw[xxx]: V3INT32 = (0, 0, 0)'
- v3int32[0]: 'slaw[xxx]: V3INT32/A(0) = []'
- v3int32[1]: 'slaw[xxx]: V3INT32/A(1) = [(0, 0, 0)]'
- v3int32[3]: 'slaw[xxx]: V3INT32/A(3) = [(0, 0, 0) ; (0, 0, 0) ; (0, 0,
    0)]'
- v3unt32: 'slaw[xxx]: V3UNT32 = (0, 0, 0)'
- v3unt32[0]: 'slaw[xxx]: V3UNT32/A(0) = []'
- v3unt32[1]: 'slaw[xxx]: V3UNT32/A(1) = [(0, 0, 0)]'
- v3unt32[3]: 'slaw[xxx]: V3UNT32/A(3) = [(0, 0, 0) ; (0, 0, 0) ; (0, 0,
    0)]'
- v3int64: 'slaw[xxx]: V3INT64 = (0, 0, 0)'
- v3int64[0]: 'slaw[xxx]: V3INT64/A(0) = []'
- v3int64[1]: 'slaw[xxx]: V3INT64/A(1) = [(0, 0, 0)]'
- v3int64[3]: 'slaw[xxx]: V3INT64/A(3) = [(0, 0, 0) ; (0, 0, 0) ; (0, 0,
    0)]'
- v3unt64: 'slaw[xxx]: V3UNT64 = (0, 0, 0)'
- v3unt64[0]: 'slaw[xxx]: V3UNT64/A(0) = []'
- v3unt64[1]: 'slaw[xxx]: V3UNT64/A(1) = [(0, 0, 0)]'
- v3unt64[3]: 'slaw[xxx]: V3UNT64/A(3) = [(0, 0, 0) ; (0, 0, 0) ; (0, 0,
    0)]'
- v3float32: 'slaw[xxx]: V3FLOAT32 = (0.000000, 0.000000, 0.000000)'
- v3float32[0]: 'slaw[xxx]: V3FLOAT32/A(0) = []'
- v3float32[1]: 'slaw[xxx]: V3FLOAT32/A(1) = [(0.000000, 0.000000, 0.000000)]'
- v3float32[3]: 'slaw[xxx]: V3FLOAT32/A(3) = [(0.000000, 0.000000, 0.000000)
    ; (0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000, 0.000000)]'
- v3float64: 'slaw[xxx]: V3FLOAT64 = (0.000000, 0.000000, 0.000000)'
- v3float64[0]: 'slaw[xxx]: V3FLOAT64/A(0) = []'
- v3float64[1]: 'slaw[xxx]: V3FLOAT64/A(1) = [(0.000000, 0.000000, 0.000000)]'
- v3float64[3]: 'slaw[xxx]: V3FLOAT64/A(3) = [(0.000000, 0.000000, 0.000000)
    ; (0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000, 0.000000)]'
- v3int8: 'slaw[xxx]: V3INT8 = (0, 0, 0)'
- v3int8[0]: 'slaw[xxx]: V3INT8/A(0) = []'
- v3int8[1]: 'slaw[xxx]: V3INT8/A(1) = [(0, 0, 0)]'
- v3int8[3]: 'slaw[xxx]: V3INT8/A(3) = [(0, 0, 0) ; (0, 0, 0) ; (0, 0, 0)]'
- v3unt8: 'slaw[xxx]: V3UNT8 = (0, 0, 0)'
- v3unt8[0]: 'slaw[xxx]: V3UNT8/A(0) = []'
- v3unt8[1]: 'slaw[xxx]: V3UNT8/A(1) = [(0, 0, 0)]'
- v3unt8[3]: 'slaw[xxx]: V3UNT8/A(3) = [(0, 0, 0) ; (0, 0, 0) ; (0, 0, 0)]'
- v3int16: 'slaw[xxx]: V3INT16 = (0, 0, 0)'
- v3int16[0]: 'slaw[xxx]: V3INT16/A(0) = []'
- v3int16[1]: 'slaw[xxx]: V3INT16/A(1) = [(0, 0, 0)]'
- v3int16[3]: 'slaw[xxx]: V3INT16/A(3) = [(0, 0, 0) ; (0, 0, 0) ; (0, 0,
    0)]'
- v3unt16: 'slaw[xxx]: V3UNT16 = (0, 0, 0)'
- v3unt16[0]: 'slaw[xxx]: V3UNT16/A(0) = []'
- v3unt16[1]: 'slaw[xxx]: V3UNT16/A(1) = [(0, 0, 0)]'
- v3unt16[3]: 'slaw[xxx]: V3UNT16/A(3) = [(0, 0, 0) ; (0, 0, 0) ; (0, 0,
    0)]'
- v4int32: 'slaw[xxx]: V4INT32 = (0, 0, 0, 0)'
- v4int32[0]: 'slaw[xxx]: V4INT32/A(0) = []'
- v4int32[1]: 'slaw[xxx]: V4INT32/A(1) = [(0, 0, 0, 0)]'
- v4int32[3]: 'slaw[xxx]: V4INT32/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- v4unt32: 'slaw[xxx]: V4UNT32 = (0, 0, 0, 0)'
- v4unt32[0]: 'slaw[xxx]: V4UNT32/A(0) = []'
- v4unt32[1]: 'slaw[xxx]: V4UNT32/A(1) = [(0, 0, 0, 0)]'
- v4unt32[3]: 'slaw[xxx]: V4UNT32/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- v4int64: 'slaw[xxx]: V4INT64 = (0, 0, 0, 0)'
- v4int64[0]: 'slaw[xxx]: V4INT64/A(0) = []'
- v4int64[1]: 'slaw[xxx]: V4INT64/A(1) = [(0, 0, 0, 0)]'
- v4int64[3]: 'slaw[xxx]: V4INT64/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- v4unt64: 'slaw[xxx]: V4UNT64 = (0, 0, 0, 0)'
- v4unt64[0]: 'slaw[xxx]: V4UNT64/A(0) = []'
- v4unt64[1]: 'slaw[xxx]: V4UNT64/A(1) = [(0, 0, 0, 0)]'
- v4unt64[3]: 'slaw[xxx]: V4UNT64/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- v4float32: 'slaw[xxx]: V4FLOAT32 = (0.000000, 0.000000, 0.000000, 0.000000)'
- v4float32[0]: 'slaw[xxx]: V4FLOAT32/A(0) = []'
- v4float32[1]: 'slaw[xxx]: V4FLOAT32/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000)]'
- v4float32[3]: 'slaw[xxx]: V4FLOAT32/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000) ; (0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000,
    0.000000, 0.000000)]'
- v4float64: 'slaw[xxx]: V4FLOAT64 = (0.000000, 0.000000, 0.000000, 0.000000)'
- v4float64[0]: 'slaw[xxx]: V4FLOAT64/A(0) = []'
- v4float64[1]: 'slaw[xxx]: V4FLOAT64/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000)]'
- v4float64[3]: 'slaw[xxx]: V4FLOAT64/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000) ; (0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000,
    0.000000, 0.000000)]'
- v4int8: 'slaw[xxx]: V4INT8 = (0, 0, 0, 0)'
- v4int8[0]: 'slaw[xxx]: V4INT8/A(0) = []'
- v4int8[1]: 'slaw[xxx]: V4INT8/A(1) = [(0, 0, 0, 0)]'
- v4int8[3]: 'slaw[xxx]: V4INT8/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ; (0,
    0, 0, 0)]'
- v4unt8: 'slaw[xxx]: V4UNT8 = (0, 0, 0, 0)'
- v4unt8[0]: 'slaw[xxx]: V4UNT8/A(0) = []'
- v4unt8[1]: 'slaw[xxx]: V4UNT8/A(1) = [(0, 0, 0, 0)]'
- v4unt8[3]: 'slaw[xxx]: V4UNT8/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ; (0,
    0, 0, 0)]'
- v4int16: 'slaw[xxx]: V4INT16 = (0, 0, 0, 0)'
- v4int16[0]: 'slaw[xxx]: V4INT16/A(0) = []'
- v4int16[1]: 'slaw[xxx]: V4INT16/A(1) = [(0, 0, 0, 0)]'
- v4int16[3]: 'slaw[xxx]: V4INT16/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- v4unt16: 'slaw[xxx]: V4UNT16 = (0, 0, 0, 0)'
- v4unt16[0]: 'slaw[xxx]: V4UNT16/A(0) = []'
- v4unt16[1]: 'slaw[xxx]: V4UNT16/A(1) = [(0, 0, 0, 0)]'
- v4unt16[3]: 'slaw[xxx]: V4UNT16/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- v2int32c: 'slaw[xxx]: V2INT32C = (0 + j0, 0 + j0)'
- v2int32c[0]: 'slaw[xxx]: V2INT32C/A(0) = []'
- v2int32c[1]: 'slaw[xxx]: V2INT32C/A(1) = [(0 + j0, 0 + j0)]'
- v2int32c[3]: 'slaw[xxx]: V2INT32C/A(3) = [(0 + j0, 0 + j0) ; (0 + j0,
    0 + j0) ; (0 + j0, 0 + j0)]'
- v2unt32c: 'slaw[xxx]: V2UNT32C = (0 + j0, 0 + j0)'
- v2unt32c[0]: 'slaw[xxx]: V2UNT32C/A(0) = []'
- v2unt32c[1]: 'slaw[xxx]: V2UNT32C/A(1) = [(0 + j0, 0 + j0)]'
- v2unt32c[3]: 'slaw[xxx]: V2UNT32C/A(3) = [(0 + j0, 0 + j0) ; (0 + j0,
    0 + j0) ; (0 + j0, 0 + j0)]'
- v2int64c: 'slaw[xxx]: V2INT64C = (0 + j0, 0 + j0)'
- v2int64c[0]: 'slaw[xxx]: V2INT64C/A(0) = []'
- v2int64c[1]: 'slaw[xxx]: V2INT64C/A(1) = [(0 + j0, 0 + j0)]'
- v2int64c[3]: 'slaw[xxx]: V2INT64C/A(3) = [(0 + j0, 0 + j0) ; (0 + j0,
    0 + j0) ; (0 + j0, 0 + j0)]'
- v2unt64c: 'slaw[xxx]: V2UNT64C = (0 + j0, 0 + j0)'
- v2unt64c[0]: 'slaw[xxx]: V2UNT64C/A(0) = []'
- v2unt64c[1]: 'slaw[xxx]: V2UNT64C/A(1) = [(0 + j0, 0 + j0)]'
- v2unt64c[3]: 'slaw[xxx]: V2UNT64C/A(3) = [(0 + j0, 0 + j0) ; (0 + j0,
    0 + j0) ; (0 + j0, 0 + j0)]'
- v2float32c: 'slaw[xxx]: V2FLOAT32C = (0.000000 + j0.000000, 0.000000 +
    j0.000000)'
- v2float32c[0]: 'slaw[xxx]: V2FLOAT32C/A(0) = []'
- v2float32c[1]: 'slaw[xxx]: V2FLOAT32C/A(1) = [(0.000000 + j0.000000, 0.000000
    + j0.000000)]'
- v2float32c[3]: 'slaw[xxx]: V2FLOAT32C/A(3) = [(0.000000 + j0.000000, 0.000000
    + j0.000000) ; (0.000000 + j0.000000, 0.000000 + j0.000000) ; (0.000000
    + j0.000000, 0.000000 + j0.000000)]'
- v2float64c: 'slaw[xxx]: V2FLOAT64C = (0.000000 + j0.000000, 0.000000 +
    j0.000000)'
- v2float64c[0]: 'slaw[xxx]: V2FLOAT64C/A(0) = []'
- v2float64c[1]: 'slaw[xxx]: V2FLOAT64C/A(1) = [(0.000000 + j0.000000, 0.000000
    + j0.000000)]'
- v2float64c[3]: 'slaw[xxx]: V2FLOAT64C/A(3) = [(0.000000 + j0.000000, 0.000000
    + j0.000000) ; (0.000000 + j0.000000, 0.000000 + j0.000000) ; (0.000000
    + j0.000000, 0.000000 + j0.000000)]'
- v2int8c: 'slaw[xxx]: V2INT8C = (0 + j0, 0 + j0)'
- v2int8c[0]: 'slaw[xxx]: V2INT8C/A(0) = []'
- v2int8c[1]: 'slaw[xxx]: V2INT8C/A(1) = [(0 + j0, 0 + j0)]'
- v2int8c[3]: 'slaw[xxx]: V2INT8C/A(3) = [(0 + j0, 0 + j0) ; (0 + j0, 0
    + j0) ; (0 + j0, 0 + j0)]'
- v2unt8c: 'slaw[xxx]: V2UNT8C = (0 + j0, 0 + j0)'
- v2unt8c[0]: 'slaw[xxx]: V2UNT8C/A(0) = []'
- v2unt8c[1]: 'slaw[xxx]: V2UNT8C/A(1) = [(0 + j0, 0 + j0)]'
- v2unt8c[3]: 'slaw[xxx]: V2UNT8C/A(3) = [(0 + j0, 0 + j0) ; (0 + j0, 0
    + j0) ; (0 + j0, 0 + j0)]'
- v2int16c: 'slaw[xxx]: V2INT16C = (0 + j0, 0 + j0)'
- v2int16c[0]: 'slaw[xxx]: V2INT16C/A(0) = []'
- v2int16c[1]: 'slaw[xxx]: V2INT16C/A(1) = [(0 + j0, 0 + j0)]'
- v2int16c[3]: 'slaw[xxx]: V2INT16C/A(3) = [(0 + j0, 0 + j0) ; (0 + j0,
    0 + j0) ; (0 + j0, 0 + j0)]'
- v2unt16c: 'slaw[xxx]: V2UNT16C = (0 + j0, 0 + j0)'
- v2unt16c[0]: 'slaw[xxx]: V2UNT16C/A(0) = []'
- v2unt16c[1]: 'slaw[xxx]: V2UNT16C/A(1) = [(0 + j0, 0 + j0)]'
- v2unt16c[3]: 'slaw[xxx]: V2UNT16C/A(3) = [(0 + j0, 0 + j0) ; (0 + j0,
    0 + j0) ; (0 + j0, 0 + j0)]'
- v3int32c: 'slaw[xxx]: V3INT32C = (0 + j0, 0 + j0, 0 + j0)'
- v3int32c[0]: 'slaw[xxx]: V3INT32C/A(0) = []'
- v3int32c[1]: 'slaw[xxx]: V3INT32C/A(1) = [(0 + j0, 0 + j0, 0 + j0)]'
- v3int32c[3]: 'slaw[xxx]: V3INT32C/A(3) = [(0 + j0, 0 + j0, 0 + j0) ; (0
    + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0)]'
- v3unt32c: 'slaw[xxx]: V3UNT32C = (0 + j0, 0 + j0, 0 + j0)'
- v3unt32c[0]: 'slaw[xxx]: V3UNT32C/A(0) = []'
- v3unt32c[1]: 'slaw[xxx]: V3UNT32C/A(1) = [(0 + j0, 0 + j0, 0 + j0)]'
- v3unt32c[3]: 'slaw[xxx]: V3UNT32C/A(3) = [(0 + j0, 0 + j0, 0 + j0) ; (0
    + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0)]'
- v3int64c: 'slaw[xxx]: V3INT64C = (0 + j0, 0 + j0, 0 + j0)'
- v3int64c[0]: 'slaw[xxx]: V3INT64C/A(0) = []'
- v3int64c[1]: 'slaw[xxx]: V3INT64C/A(1) = [(0 + j0, 0 + j0, 0 + j0)]'
- v3int64c[3]: 'slaw[xxx]: V3INT64C/A(3) = [(0 + j0, 0 + j0, 0 + j0) ; (0
    + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0)]'
- v3unt64c: 'slaw[xxx]: V3UNT64C = (0 + j0, 0 + j0, 0 + j0)'
- v3unt64c[0]: 'slaw[xxx]: V3UNT64C/A(0) = []'
- v3unt64c[1]: 'slaw[xxx]: V3UNT64C/A(1) = [(0 + j0, 0 + j0, 0 + j0)]'
- v3unt64c[3]: 'slaw[xxx]: V3UNT64C/A(3) = [(0 + j0, 0 + j0, 0 + j0) ; (0
    + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0)]'
- v3float32c: 'slaw[xxx]: V3FLOAT32C = (0.000000 + j0.000000, 0.000000 +
    j0.000000, 0.000000 + j0.000000)'
- v3float32c[0]: 'slaw[xxx]: V3FLOAT32C/A(0) = []'
- v3float32c[1]: 'slaw[xxx]: V3FLOAT32C/A(1) = [(0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000)]'
- v3float32c[3]: 'slaw[xxx]: V3FLOAT32C/A(3) = [(0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000) ; (0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000) ; (0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000)]'
- v3float64c: 'slaw[xxx]: V3FLOAT64C = (0.000000 + j0.000000, 0.000000 +
    j0.000000, 0.000000 + j0.000000)'
- v3float64c[0]: 'slaw[xxx]: V3FLOAT64C/A(0) = []'
- v3float64c[1]: 'slaw[xxx]: V3FLOAT64C/A(1) = [(0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000)]'
- v3float64c[3]: 'slaw[xxx]: V3FLOAT64C/A(3) = [(0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000) ; (0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000) ; (0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000)]'
- v3int8c: 'slaw[xxx]: V3INT8C = (0 + j0, 0 + j0, 0 + j0)'
- v3int8c[0]: 'slaw[xxx]: V3INT8C/A(0) = []'
- v3int8c[1]: 'slaw[xxx]: V3INT8C/A(1) = [(0 + j0, 0 + j0, 0 + j0)]'
- v3int8c[3]: 'slaw[xxx]: V3INT8C/A(3) = [(0 + j0, 0 + j0, 0 + j0) ; (0
    + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0)]'
- v3unt8c: 'slaw[xxx]: V3UNT8C = (0 + j0, 0 + j0, 0 + j0)'
- v3unt8c[0]: 'slaw[xxx]: V3UNT8C/A(0) = []'
- v3unt8c[1]: 'slaw[xxx]: V3UNT8C/A(1) = [(0 + j0, 0 + j0, 0 + j0)]'
- v3unt8c[3]: 'slaw[xxx]: V3UNT8C/A(3) = [(0 + j0, 0 + j0, 0 + j0) ; (0
    + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0)]'
- v3int16c: 'slaw[xxx]: V3INT16C = (0 + j0, 0 + j0, 0 + j0)'
- v3int16c[0]: 'slaw[xxx]: V3INT16C/A(0) = []'
- v3int16c[1]: 'slaw[xxx]: V3INT16C/A(1) = [(0 + j0, 0 + j0, 0 + j0)]'
- v3int16c[3]: 'slaw[xxx]: V3INT16C/A(3) = [(0 + j0, 0 + j0, 0 + j0) ; (0
    + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0)]'
- v3unt16c: 'slaw[xxx]: V3UNT16C = (0 + j0, 0 + j0, 0 + j0)'
- v3unt16c[0]: 'slaw[xxx]: V3UNT16C/A(0) = []'
- v3unt16c[1]: 'slaw[xxx]: V3UNT16C/A(1) = [(0 + j0, 0 + j0, 0 + j0)]'
- v3unt16c[3]: 'slaw[xxx]: V3UNT16C/A(3) = [(0 + j0, 0 + j0, 0 + j0) ; (0
    + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0)]'
- v4int32c: 'slaw[xxx]: V4INT32C = (0 + j0, 0 + j0, 0 + j0, 0 + j0)'
- v4int32c[0]: 'slaw[xxx]: V4INT32C/A(0) = []'
- v4int32c[1]: 'slaw[xxx]: V4INT32C/A(1) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0)]'
- v4int32c[3]: 'slaw[xxx]: V4INT32C/A(3) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0) ; (0 + j0, 0 + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0, 0
    + j0)]'
- v4unt32c: 'slaw[xxx]: V4UNT32C = (0 + j0, 0 + j0, 0 + j0, 0 + j0)'
- v4unt32c[0]: 'slaw[xxx]: V4UNT32C/A(0) = []'
- v4unt32c[1]: 'slaw[xxx]: V4UNT32C/A(1) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0)]'
- v4unt32c[3]: 'slaw[xxx]: V4UNT32C/A(3) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0) ; (0 + j0, 0 + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0, 0
    + j0)]'
- v4int64c: 'slaw[xxx]: V4INT64C = (0 + j0, 0 + j0, 0 + j0, 0 + j0)'
- v4int64c[0]: 'slaw[xxx]: V4INT64C/A(0) = []'
- v4int64c[1]: 'slaw[xxx]: V4INT64C/A(1) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0)]'
- v4int64c[3]: 'slaw[xxx]: V4INT64C/A(3) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0) ; (0 + j0, 0 + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0, 0
    + j0)]'
- v4unt64c: 'slaw[xxx]: V4UNT64C = (0 + j0, 0 + j0, 0 + j0, 0 + j0)'
- v4unt64c[0]: 'slaw[xxx]: V4UNT64C/A(0) = []'
- v4unt64c[1]: 'slaw[xxx]: V4UNT64C/A(1) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0)]'
- v4unt64c[3]: 'slaw[xxx]: V4UNT64C/A(3) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0) ; (0 + j0, 0 + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0, 0
    + j0)]'
- v4float32c: 'slaw[xxx]: V4FLOAT32C = (0.000000 + j0.000000, 0.000000 +
    j0.000000, 0.000000 + j0.000000, 0.000000 + j0.000000)'
- v4float32c[0]: 'slaw[xxx]: V4FLOAT32C/A(0) = []'
- v4float32c[1]: 'slaw[xxx]: V4FLOAT32C/A(1) = [(0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000, 0.000000 + j0.000000)]'
- v4float32c[3]: 'slaw[xxx]: V4FLOAT32C/A(3) = [(0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000, 0.000000 + j0.000000) ; (0.000000
    + j0.000000, 0.000000 + j0.000000, 0.000000 + j0.000000, 0.000000 +
    j0.000000) ; (0.000000 + j0.000000, 0.000000 + j0.000000, 0.000000 +
    j0.000000, 0.000000 + j0.000000)]'
- v4float64c: 'slaw[xxx]: V4FLOAT64C = (0.000000 + j0.000000, 0.000000 +
    j0.000000, 0.000000 + j0.000000, 0.000000 + j0.000000)'
- v4float64c[0]: 'slaw[xxx]: V4FLOAT64C/A(0) = []'
- v4float64c[1]: 'slaw[xxx]: V4FLOAT64C/A(1) = [(0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000, 0.000000 + j0.000000)]'
- v4float64c[3]: 'slaw[xxx]: V4FLOAT64C/A(3) = [(0.000000 + j0.000000, 0.000000
    + j0.000000, 0.000000 + j0.000000, 0.000000 + j0.000000) ; (0.000000
    + j0.000000, 0.000000 + j0.000000, 0.000000 + j0.000000, 0.000000 +
    j0.000000) ; (0.000000 + j0.000000, 0.000000 + j0.000000, 0.000000 +
    j0.000000, 0.000000 + j0.000000)]'
- v4int8c: 'slaw[xxx]: V4INT8C = (0 + j0, 0 + j0, 0 + j0, 0 + j0)'
- v4int8c[0]: 'slaw[xxx]: V4INT8C/A(0) = []'
- v4int8c[1]: 'slaw[xxx]: V4INT8C/A(1) = [(0 + j0, 0 + j0, 0 + j0, 0 + j0)]'
- v4int8c[3]: 'slaw[xxx]: V4INT8C/A(3) = [(0 + j0, 0 + j0, 0 + j0, 0 + j0)
    ; (0 + j0, 0 + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0, 0 + j0)]'
- v4unt8c: 'slaw[xxx]: V4UNT8C = (0 + j0, 0 + j0, 0 + j0, 0 + j0)'
- v4unt8c[0]: 'slaw[xxx]: V4UNT8C/A(0) = []'
- v4unt8c[1]: 'slaw[xxx]: V4UNT8C/A(1) = [(0 + j0, 0 + j0, 0 + j0, 0 + j0)]'
- v4unt8c[3]: 'slaw[xxx]: V4UNT8C/A(3) = [(0 + j0, 0 + j0, 0 + j0, 0 + j0)
    ; (0 + j0, 0 + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0, 0 + j0)]'
- v4int16c: 'slaw[xxx]: V4INT16C = (0 + j0, 0 + j0, 0 + j0, 0 + j0)'
- v4int16c[0]: 'slaw[xxx]: V4INT16C/A(0) = []'
- v4int16c[1]: 'slaw[xxx]: V4INT16C/A(1) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0)]'
- v4int16c[3]: 'slaw[xxx]: V4INT16C/A(3) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0) ; (0 + j0, 0 + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0, 0
    + j0)]'
- v4unt16c: 'slaw[xxx]: V4UNT16C = (0 + j0, 0 + j0, 0 + j0, 0 + j0)'
- v4unt16c[0]: 'slaw[xxx]: V4UNT16C/A(0) = []'
- v4unt16c[1]: 'slaw[xxx]: V4UNT16C/A(1) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0)]'
- v4unt16c[3]: 'slaw[xxx]: V4UNT16C/A(3) = [(0 + j0, 0 + j0, 0 + j0, 0 +
    j0) ; (0 + j0, 0 + j0, 0 + j0, 0 + j0) ; (0 + j0, 0 + j0, 0 + j0, 0
    + j0)]'
- m2int32: 'slaw[xxx]: M2INT32 = (0, 0, 0, 0)'
- m2int32[0]: 'slaw[xxx]: M2INT32/A(0) = []'
- m2int32[1]: 'slaw[xxx]: M2INT32/A(1) = [(0, 0, 0, 0)]'
- m2int32[3]: 'slaw[xxx]: M2INT32/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- m2unt32: 'slaw[xxx]: M2UNT32 = (0, 0, 0, 0)'
- m2unt32[0]: 'slaw[xxx]: M2UNT32/A(0) = []'
- m2unt32[1]: 'slaw[xxx]: M2UNT32/A(1) = [(0, 0, 0, 0)]'
- m2unt32[3]: 'slaw[xxx]: M2UNT32/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- m2int64: 'slaw[xxx]: M2INT64 = (0, 0, 0, 0)'
- m2int64[0]: 'slaw[xxx]: M2INT64/A(0) = []'
- m2int64[1]: 'slaw[xxx]: M2INT64/A(1) = [(0, 0, 0, 0)]'
- m2int64[3]: 'slaw[xxx]: M2INT64/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- m2unt64: 'slaw[xxx]: M2UNT64 = (0, 0, 0, 0)'
- m2unt64[0]: 'slaw[xxx]: M2UNT64/A(0) = []'
- m2unt64[1]: 'slaw[xxx]: M2UNT64/A(1) = [(0, 0, 0, 0)]'
- m2unt64[3]: 'slaw[xxx]: M2UNT64/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- m2float32: 'slaw[xxx]: M2FLOAT32 = (0.000000, 0.000000, 0.000000, 0.000000)'
- m2float32[0]: 'slaw[xxx]: M2FLOAT32/A(0) = []'
- m2float32[1]: 'slaw[xxx]: M2FLOAT32/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000)]'
- m2float32[3]: 'slaw[xxx]: M2FLOAT32/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000) ; (0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000,
    0.000000, 0.000000)]'
- m2float64: 'slaw[xxx]: M2FLOAT64 = (0.000000, 0.000000, 0.000000, 0.000000)'
- m2float64[0]: 'slaw[xxx]: M2FLOAT64/A(0) = []'
- m2float64[1]: 'slaw[xxx]: M2FLOAT64/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000)]'
- m2float64[3]: 'slaw[xxx]: M2FLOAT64/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000) ; (0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000,
    0.000000, 0.000000)]'
- m2int8: 'slaw[xxx]: M2INT8 = (0, 0, 0, 0)'
- m2int8[0]: 'slaw[xxx]: M2INT8/A(0) = []'
- m2int8[1]: 'slaw[xxx]: M2INT8/A(1) = [(0, 0, 0, 0)]'
- m2int8[3]: 'slaw[xxx]: M2INT8/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ; (0,
    0, 0, 0)]'
- m2unt8: 'slaw[xxx]: M2UNT8 = (0, 0, 0, 0)'
- m2unt8[0]: 'slaw[xxx]: M2UNT8/A(0) = []'
- m2unt8[1]: 'slaw[xxx]: M2UNT8/A(1) = [(0, 0, 0, 0)]'
- m2unt8[3]: 'slaw[xxx]: M2UNT8/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ; (0,
    0, 0, 0)]'
- m2int16: 'slaw[xxx]: M2INT16 = (0, 0, 0, 0)'
- m2int16[0]: 'slaw[xxx]: M2INT16/A(0) = []'
- m2int16[1]: 'slaw[xxx]: M2INT16/A(1) = [(0, 0, 0, 0)]'
- m2int16[3]: 'slaw[xxx]: M2INT16/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- m2unt16: 'slaw[xxx]: M2UNT16 = (0, 0, 0, 0)'
- m2unt16[0]: 'slaw[xxx]: M2UNT16/A(0) = []'
- m2unt16[1]: 'slaw[xxx]: M2UNT16/A(1) = [(0, 0, 0, 0)]'
- m2unt16[3]: 'slaw[xxx]: M2UNT16/A(3) = [(0, 0, 0, 0) ; (0, 0, 0, 0) ;
    (0, 0, 0, 0)]'
- m3int32: 'slaw[xxx]: M3INT32 = (0, 0, 0, 0, 0, 0, 0, 0)'
- m3int32[0]: 'slaw[xxx]: M3INT32/A(0) = []'
- m3int32[1]: 'slaw[xxx]: M3INT32/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0)]'
- m3int32[3]: 'slaw[xxx]: M3INT32/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0) ; (0,
    0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0)]'
- m3unt32: 'slaw[xxx]: M3UNT32 = (0, 0, 0, 0, 0, 0, 0, 0)'
- m3unt32[0]: 'slaw[xxx]: M3UNT32/A(0) = []'
- m3unt32[1]: 'slaw[xxx]: M3UNT32/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0)]'
- m3unt32[3]: 'slaw[xxx]: M3UNT32/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0) ; (0,
    0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0)]'
- m3int64: 'slaw[xxx]: M3INT64 = (0, 0, 0, 0, 0, 0, 0, 0)'
- m3int64[0]: 'slaw[xxx]: M3INT64/A(0) = []'
- m3int64[1]: 'slaw[xxx]: M3INT64/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0)]'
- m3int64[3]: 'slaw[xxx]: M3INT64/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0) ; (0,
    0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0)]'
- m3unt64: 'slaw[xxx]: M3UNT64 = (0, 0, 0, 0, 0, 0, 0, 0)'
- m3unt64[0]: 'slaw[xxx]: M3UNT64/A(0) = []'
- m3unt64[1]: 'slaw[xxx]: M3UNT64/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0)]'
- m3unt64[3]: 'slaw[xxx]: M3UNT64/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0) ; (0,
    0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0)]'
- m3float32: 'slaw[xxx]: M3FLOAT32 = (0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000)'
- m3float32[0]: 'slaw[xxx]: M3FLOAT32/A(0) = []'
- m3float32[1]: 'slaw[xxx]: M3FLOAT32/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000)]'
- m3float32[3]: 'slaw[xxx]: M3FLOAT32/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000)]'
- m3float64: 'slaw[xxx]: M3FLOAT64 = (0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000)'
- m3float64[0]: 'slaw[xxx]: M3FLOAT64/A(0) = []'
- m3float64[1]: 'slaw[xxx]: M3FLOAT64/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000)]'
- m3float64[3]: 'slaw[xxx]: M3FLOAT64/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000)]'
- m3int8: 'slaw[xxx]: M3INT8 = (0, 0, 0, 0, 0, 0, 0, 0)'
- m3int8[0]: 'slaw[xxx]: M3INT8/A(0) = []'
- m3int8[1]: 'slaw[xxx]: M3INT8/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0)]'
- m3int8[3]: 'slaw[xxx]: M3INT8/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0,
    0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0)]'
- m3unt8: 'slaw[xxx]: M3UNT8 = (0, 0, 0, 0, 0, 0, 0, 0)'
- m3unt8[0]: 'slaw[xxx]: M3UNT8/A(0) = []'
- m3unt8[1]: 'slaw[xxx]: M3UNT8/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0)]'
- m3unt8[3]: 'slaw[xxx]: M3UNT8/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0,
    0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0)]'
- m3int16: 'slaw[xxx]: M3INT16 = (0, 0, 0, 0, 0, 0, 0, 0)'
- m3int16[0]: 'slaw[xxx]: M3INT16/A(0) = []'
- m3int16[1]: 'slaw[xxx]: M3INT16/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0)]'
- m3int16[3]: 'slaw[xxx]: M3INT16/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0) ; (0,
    0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0)]'
- m3unt16: 'slaw[xxx]: M3UNT16 = (0, 0, 0, 0, 0, 0, 0, 0)'
- m3unt16[0]: 'slaw[xxx]: M3UNT16/A(0) = []'
- m3unt16[1]: 'slaw[xxx]: M3UNT16/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0)]'
- m3unt16[3]: 'slaw[xxx]: M3UNT16/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0) ; (0,
    0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0)]'
- m4int32: 'slaw[xxx]: M4INT32 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0)'
- m4int32[0]: 'slaw[xxx]: M4INT32/A(0) = []'
- m4int32[1]: 'slaw[xxx]: M4INT32/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0)]'
- m4int32[3]: 'slaw[xxx]: M4INT32/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m4unt32: 'slaw[xxx]: M4UNT32 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0)'
- m4unt32[0]: 'slaw[xxx]: M4UNT32/A(0) = []'
- m4unt32[1]: 'slaw[xxx]: M4UNT32/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0)]'
- m4unt32[3]: 'slaw[xxx]: M4UNT32/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m4int64: 'slaw[xxx]: M4INT64 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0)'
- m4int64[0]: 'slaw[xxx]: M4INT64/A(0) = []'
- m4int64[1]: 'slaw[xxx]: M4INT64/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0)]'
- m4int64[3]: 'slaw[xxx]: M4INT64/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m4unt64: 'slaw[xxx]: M4UNT64 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0)'
- m4unt64[0]: 'slaw[xxx]: M4UNT64/A(0) = []'
- m4unt64[1]: 'slaw[xxx]: M4UNT64/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0)]'
- m4unt64[3]: 'slaw[xxx]: M4UNT64/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m4float32: 'slaw[xxx]: M4FLOAT32 = (0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000)'
- m4float32[0]: 'slaw[xxx]: M4FLOAT32/A(0) = []'
- m4float32[1]: 'slaw[xxx]: M4FLOAT32/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000)]'
- m4float32[3]: 'slaw[xxx]: M4FLOAT32/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000) ; (0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000)]'
- m4float64: 'slaw[xxx]: M4FLOAT64 = (0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000)'
- m4float64[0]: 'slaw[xxx]: M4FLOAT64/A(0) = []'
- m4float64[1]: 'slaw[xxx]: M4FLOAT64/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000)]'
- m4float64[3]: 'slaw[xxx]: M4FLOAT64/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000) ; (0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000)]'
- m4int8: 'slaw[xxx]: M4INT8 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0)'
- m4int8[0]: 'slaw[xxx]: M4INT8/A(0) = []'
- m4int8[1]: 'slaw[xxx]: M4INT8/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0)]'
- m4int8[3]: 'slaw[xxx]: M4INT8/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ;
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m4unt8: 'slaw[xxx]: M4UNT8 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0)'
- m4unt8[0]: 'slaw[xxx]: M4UNT8/A(0) = []'
- m4unt8[1]: 'slaw[xxx]: M4UNT8/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0)]'
- m4unt8[3]: 'slaw[xxx]: M4UNT8/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ;
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m4int16: 'slaw[xxx]: M4INT16 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0)'
- m4int16[0]: 'slaw[xxx]: M4INT16/A(0) = []'
- m4int16[1]: 'slaw[xxx]: M4INT16/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0)]'
- m4int16[3]: 'slaw[xxx]: M4INT16/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m4unt16: 'slaw[xxx]: M4UNT16 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0)'
- m4unt16[0]: 'slaw[xxx]: M4UNT16/A(0) = []'
- m4unt16[1]: 'slaw[xxx]: M4UNT16/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0)]'
- m4unt16[3]: 'slaw[xxx]: M4UNT16/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5int32: 'slaw[xxx]: M5INT32 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'
- m5int32[0]: 'slaw[xxx]: M5INT32/A(0) = []'
- m5int32[1]: 'slaw[xxx]: M5INT32/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5int32[3]: 'slaw[xxx]: M5INT32/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ;
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5unt32: 'slaw[xxx]: M5UNT32 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'
- m5unt32[0]: 'slaw[xxx]: M5UNT32/A(0) = []'
- m5unt32[1]: 'slaw[xxx]: M5UNT32/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5unt32[3]: 'slaw[xxx]: M5UNT32/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ;
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5int64: 'slaw[xxx]: M5INT64 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'
- m5int64[0]: 'slaw[xxx]: M5INT64/A(0) = []'
- m5int64[1]: 'slaw[xxx]: M5INT64/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5int64[3]: 'slaw[xxx]: M5INT64/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ;
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5unt64: 'slaw[xxx]: M5UNT64 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'
- m5unt64[0]: 'slaw[xxx]: M5UNT64/A(0) = []'
- m5unt64[1]: 'slaw[xxx]: M5UNT64/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5unt64[3]: 'slaw[xxx]: M5UNT64/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ;
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5float32: 'slaw[xxx]: M5FLOAT32 = (0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000)'
- m5float32[0]: 'slaw[xxx]: M5FLOAT32/A(0) = []'
- m5float32[1]: 'slaw[xxx]: M5FLOAT32/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000)]'
- m5float32[3]: 'slaw[xxx]: M5FLOAT32/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000) ; (0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000)]'
- m5float64: 'slaw[xxx]: M5FLOAT64 = (0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000)'
- m5float64[0]: 'slaw[xxx]: M5FLOAT64/A(0) = []'
- m5float64[1]: 'slaw[xxx]: M5FLOAT64/A(1) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000)]'
- m5float64[3]: 'slaw[xxx]: M5FLOAT64/A(3) = [(0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000) ; (0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000) ; (0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
    0.000000, 0.000000)]'
- m5int8: 'slaw[xxx]: M5INT8 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'
- m5int8[0]: 'slaw[xxx]: M5INT8/A(0) = []'
- m5int8[1]: 'slaw[xxx]: M5INT8/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5int8[3]: 'slaw[xxx]: M5INT8/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ; (0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5unt8: 'slaw[xxx]: M5UNT8 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'
- m5unt8[0]: 'slaw[xxx]: M5UNT8/A(0) = []'
- m5unt8[1]: 'slaw[xxx]: M5UNT8/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5unt8[3]: 'slaw[xxx]: M5UNT8/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ; (0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5int16: 'slaw[xxx]: M5INT16 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'
- m5int16[0]: 'slaw[xxx]: M5INT16/A(0) = []'
- m5int16[1]: 'slaw[xxx]: M5INT16/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5int16[3]: 'slaw[xxx]: M5INT16/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ;
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5unt16: 'slaw[xxx]: M5UNT16 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'
- m5unt16[0]: 'slaw[xxx]: M5UNT16/A(0) = []'
- m5unt16[1]: 'slaw[xxx]: M5UNT16/A(1) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- m5unt16[3]: 'slaw[xxx]: M5UNT16/A(3) = [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) ;
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0) ; (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]'
- file: "slaw[xxx]: PROT: ((\ndescrips:\nslaw[xxx]: LIST (4 elems): {\n
    1: slaw[xxx]: STR(6): \":mouse\"\n 2: slaw[xxx]: STR(4): \":usb\"\n
    3: slaw[xxx]: STR(9): \":0x347689\"\n 4: slaw[xxx]: STR(5): \":down\"\n
    }\ningests:\nslaw[xxx]: LIST (35 elems): {\n 1: slaw[xxx]: CONS:\n 1:
    \ L: slaw[xxx]: STR(5): \"hello\"\n 1:  R: slaw[xxx]: STR(5): \"world\"\n
    2: slaw[xxx]: CONS:\n 2:  L: slaw[xxx]: STR(16): \"a nested protein\"\n
    2:  R: slaw[xxx]: PROT: ((\n 2:  R: descrips:\n 2:  R: slaw[xxx]: LIST
    (4 elems): {\n 2:  R:  1: slaw[xxx]: STR(6): \":mouse\"\n 2:  R:  2:
    slaw[xxx]: STR(4): \":usb\"\n 2:  R:  3: slaw[xxx]: STR(9): \":0x347689\"\n
    2:  R:  4: slaw[xxx]: STR(5): \":down\"\n 2:  R:  }\n 2:  R: ingests:\n
    2:  R: slaw[xxx]: LIST (1 elems): {\n 2:  R:  1: slaw[xxx]: CONS:\n
    2:  R:  1:  L: slaw[xxx]: STR(5): \"hello\"\n 2:  R:  1:  R: slaw[xxx]:
    STR(5): \"world\"\n 2:  R:  }\n 2:  R:  ))\n 3: slaw[xxx]: CONS:\n 3:
    \ L: slaw[xxx]: STR(7): \"Address\"\n 3:  R: slaw[xxx]: LIST (8 elems):
    {\n 3:  R:  1: slaw[xxx]: UNT16 = 923\n 3:  R:  2: slaw[xxx]: STR(2):
    \"E.\"\n 3:  R:  3: slaw[xxx]: UNT8 = 3\n 3:  R:  4: slaw[xxx]: STR(11):
    \"rd St. Unit\"\n 3:  R:  5: slaw[xxx]: UNT8 = 111\n 3:  R:  6: slaw[xxx]:
    CONS:\n 3:  R:  6:  L: slaw[xxx]: STR(11): \"Los Angeles\"\n 3:  R:
    \ 6:  R: slaw[xxx]: STR(2): \"CA\"\n 3:  R:  7: slaw[xxx]: UNT32 = 90013\n
    3:  R:  8: slaw[xxx]: UNT16/A(3) = [213 ; 683 ; 8863]\n 3:  R:  }\n
    4: slaw[xxx]: CONS:\n 4:  L: slaw[xxx]: STR(19): \" the final frontier\"\n
    4:  R: slaw[xxx]: CONS:\n 4:  R:  L: slaw[xxx]: STR(3): \"NCC\"\n 4:
    \ R:  R: slaw[xxx]: INT16 = -1701\n 5: slaw[xxx]: CONS:\n 5:  L: slaw[xxx]:
    STR(21): \"a large block of text\"\n 5:  R: slaw[xxx]: STR(19569): \"--
    Description: Proteins, Pools, & Slaw --\n\nThis text describes initial
    libPlasma components used for exchange of\ndata within and between computing
    processes.\n\nA \"process,\" in our usage, means a computer program
    executing for a\nperiod of time. This execution may be interrupted by
    pauses or\ntransfers between processors or machines, so that a process
    is\npossibly suspended indefinitely and \"serialized\" or \"marshaled\"
    to\ndisk, across a memory bus, or over a network.\n\nThe present work's
    context is a new programming environment that\npermits (indeed: encourages)
    large scale multi-process\ninteroperation. Existing programming environments
    do not fully support\nmulti-cpu and cross-network execution, or flexible
    sharing of data\nbetween large numbers of computing processes.\n\nIn
    pursuit of this goal we have designed and implemented several\nconstructs
    that together enable\n\n - Efficient exchange of data between large
    numbers of processes\n - Flexible data \"typing\" and structure, so
    that widely varying kinds\n   and uses of data are supported\n - Flexible
    mechanisms for data exchange (local memory, disk,\n   network, etc.),
    all driven by substantially similar APIs.\n - Data exchange between
    processes written in different programming\n   languages\n - Automatic
    maintenance of data caching and aggregate state\n\nThe principal constructs
    include slawx (plural of \"slaw\"), a mechanism\nfor efficient, platform-independent
    data representation and access;\nproteins, a data encapsulation and
    transport scheme (whose payload is\ngenerally and ideally slawx); and
    pools, which provide structured yet\nflexible aggregation, ordering,
    filtering, and distribution of\nproteins -- within a process, among
    local processes, across a network\nbetween remote or distributed processes,
    and via 'longer term'\n(e.g. on-disk) storage.\n\n\n- Proteins -\n\nThe
    \"protein\" is a new mechanism for encapsulating data that needs to\nbe
    shared between processes (or moved across a bus or network).\n\nA protein
    is a structured record format and an associated set of\nmethods for
    manipulating records (putting data in, taking data out,\nquerying the
    format and existence of data). Proteins are designed to\nbe used via
    code written in a variety of computer languages; to be the\nbasic building
    block for \"pools\", described below; and to be natively\nable to move
    between processors and across networks while maintaining\nintact the
    data they contain.\n\nOne immediate -- and important -- use of proteins
    is as an improved\nmechanism for transport and manipulation of user
    interface \"events.\"\nToday's mainstream, user-facing computing platforms
    (OS X, Microsoft\nWindows, X Windows) provide facilities for transmitting
    user interface\nevent data between processes. But these existing mechanisms
    all suffer\nfrom several major design shortcomings that make it difficult
    to build\nmulti-process and multi-machine applications, and that force
    users\nworking in more than one programming language to jump through\nfrustrating
    hoops. Existing event frameworks are\n\n - strongly typed, which makes
    them inflexible, privileges the\n   assumptions of the systems vendor
    over the application programmer,\n   and forms a mis-match with the
    facilities of increasingly popular\n   dynamic languages (such as Ruby,
    Python and Perl)\n - point-to-point, which makes coordinating the activity
    of more than\n   a few distinct processes difficult or impossible\n
    - strongly dependent on particular local, in-memory data structures,\n
    \  which renders them unsuited for on-disk storage or transmission\n
    \  across a network\n\nIn contrast, proteins are untyped (but provide
    a powerful and flexible\npattern-matching facility, on top of which
    \"type-like\" functionality\nis implemented); are inherently multi-point
    (although point-to-point\nforms are easily implemented as a subset of
    multi-point transmission);\nand define a \"universal\" record format
    that does not differ (or\ndiffers only in the types of optional optimizations
    that are\nperformed) between in-memory, on-disk, and on-the-wire (network)\nformats.\n\nA
    protein is a linear sequence of bytes. Within these bytes are\nencapsulated
    a \"descrips\" list -- an arbitrarily elaborate but\nefficiently filterable
    per-protein description -- and a set of\nkey-value pairs called \"ingests\"
    -- the actual \"contents\" of the\nprotein.\n\nA minimal (and read-only)
    protein implementation might define the\nfollowing behaviors in one
    or more programming languages:\n\n - query the length in bytes of a
    protein\n - query the number of descrips entries\n - query the number
    of ingests\n - retrieve a descrip entry by index number\n - retrieve
    an ingest by index number\n\nIn addition, most implementations also
    define basic methods allowing\nproteins to be constructed and filled
    with data, helper-methods that\nmake common tasks easier for programmers,
    and hooks for creating\noptimizations:\n\n - create a new protein\n
    - append a series of descrips entries\n - append an ingest\n - query
    the presence of a matching descrip\n - query the presence of a matching
    ingest key\n - retrieve an ingest value given a key\n - pattern match
    across descrips\n - delete one or more descrips\n - delete one or more
    ingests\n - embed non-structured metadata near the beginning of a protein\n\nProteins'
    concern with key-value pairs, as well as some core ideas\nabout network-friendly
    and multi-point data interchange, are shared\nwith earlier systems that
    privilege the concept of \"tuples\" (examples\ninclude Linda and Jini).
    Proteins differ from tuple-oriented systems\nin several major ways,
    including the use of the descrips list to\nprovide a standard, optimizable
    pattern matching substrate; and the\nrigorous specification of a record
    format appropriate for a variety of\nstorage and language constructs
    (along with several particular\nimplementations of \"interfaces\" to
    that record format).\n\nFollowing is a somewhat detailed account of
    proteins' present\nspecification. Note that the specification is still
    subject to\noccasional adjustments and improvements; the account is
    presented here\nmerely by way of illustrating the system's character.\n\nThe
    first four or eight bytes of a protein specify the protein's\nlength,
    which must be a multiple of 16 bytes. This 16-byte\ngranularity ensures
    that byte- and bus-alignment efficiencies are\nachievable on contemporary
    hardware. A protein that is not naturally\n\"quad-word aligned\" must
    be padded with arbritrary bytes so that its\nlength is a multiple of
    16 bytes.\n\nThe length portion of a protein has the following format:
    32 bits\nspecifying length, in big-endian format, with the four lowest-order\nbits
    serving as flags to indicate macro-level protein structure\ncharacteristics;
    followed by 32 further bits if the protein's length\nis greater than
    2^32 bytes.\n\nThe 16-byte-alignment proviso means that the lowest order
    bits of the\nfirst four bytes are available as flags. And so the first
    three\nlow-order bit flags indicate whether the protein's length can
    be\nexpressed in the first four bytes or requires eight; whether the\nprotein
    uses big-endian or little-endian byte ordering; and whether\nthe protein
    employs standard or non-standard structure. The fourth\nflag bit is
    reserved for future use.\n\nIf the eight-byte length flag bit is set,
    the length of the protein is\ncalculated by reading the next four bytes
    and using them as the\nhigh-order bytes of a big-endian, eight-byte
    integer (with the four\nbytes already read supplying the low-order portion).\n\nIf
    the little-endian flag is set, all binary numerical data in the\nprotein
    is to be interpreted as little-endian (otherwise,\nbig-endian). If the
    non-standard flag bit is set, the remainder of the\nprotein does not
    conform to the standard structure to be described\nbelow.\n\nWe will
    not further discuss non-standard protein structures, except to\nsay
    that there are various methods for describing and synchronizing on\nnon-standard
    protein formats available to a systems programmer using\nproteins and
    pools, and that these methods can be useful when space or\ncompute cycles
    are constrained. For example, the shortest protein is\n-- by definition
    -- sixteen bytes. A standard-format protein cannot\nfit any actual payload
    data into those sixteen bytes (the lion's share\nof which is already
    relegated to describing the location of the\nprotein's component parts).
    But a non-standard format protein could\nconceivably use 12 of its 16
    bytes for data. And two applications\nexchanging proteins could mutually
    decide that any 16-byte-long\nproteins that they emit always contain
    12 bytes representing, for\nexample, 12 8-bit sensor values from a real-time
    analog-to-digital\nconvertor.\n\nThe remainder of this section describes
    a standard protein's layout.\n\nImmediately following the length header,
    two more variable-length\ninteger numbers appear. These numbers specify
    offsets to,\nrespectively, the first element in the descrips list and
    the first\nkey-value pair. The byte order of each quad of these numbers
    is\nspecified by the protein's endianness flag bit. For each, the most\nsignificant
    bit of the first four bytes determines whether the number\nis four or
    eight bytes wide. If the msb is set, the first four bytes\nare the most
    significant bytes of a double-word (eight byte)\nnumber. We will refer
    to this as \"offset form\".\n\nThe presence of these two offsets at
    the beginning of a protein allows\nfor several useful optimizations.\n\nMost
    proteins will not be so large as to require eight-byte lengths or\npointers,
    so in general the length (with flags) and two offset numbers\nwill occupy
    only the first three bytes of a protein. On many hardware\narchitectures,
    a fetch or read of a certain number of bytes beyond the\nfirst is \"free\"
    (16 bytes, for example, take exactly the same number\nof clock cycles
    to pull across the Cell processor's main bus as a\nsingle byte).\n\nIn
    many instances it is useful to allow implementation- or\ncontext-specific
    caching or metadata inside a protein. The use of\noffsets allows for
    a flexibly-sized \"hole\" to be created near the\nbeginning of the protein,
    into which such metadata may be slotted. An\nimplementation that can
    make use of eight bytes of metadata gets those\nbytes for free on many
    architectures with every fetch of the length\nheader for a protein.\n\nUse
    of separate offsets pointing to descrips and pairs allows descrips\nand
    pairs to be handled by different code paths, making possible\nparticular
    optimizations relating to, for example, descrips\npattern-matching and
    protein assembly.\n\nThe descrips offset specifies the number of bytes
    between the\nbeginning of the protein and the first descrip entry. Each
    descrip\nentry consists of an offset (in offset form, of course) to
    the next\ndescrip entry, followed by a variable-width length field (again
    in\noffset format), followed by a \"slaw\" (discussed separately, below).
    If\nthere are no further descrips, the offset is, by rule, four bytes
    of\nzeros. Otherwise, the offset specifies the number of bytes between
    the\nbeginning of this descrip entry and the next one. The length field\nspecifies
    the length of the slaw, in bytes.\n\nIn most proteins, each descrip
    is a string, formatted in the slaw\nstring fashion: a four-byte length/type
    header with the most\nsignificant bit set and only the lower 30 bits
    used to specify length,\nfollowed by the header's indicated number of
    data bytes. As usual, the\nlength header takes its endianness from the
    protein. Bytes are assumed\nto encode UTF-8 characters (and thus --
    nota bene -- the number of\ncharacters is not necessarily the same as
    the number of bytes).\n\nThe duplication of length data in both the
    protein descrip entry\nlength field and the slaw string header is a
    candidate for\noptimization.\n\nThe ingests offset specifies the number
    of bytes between the beginning\nof the protein and the first ingest
    entry. Each ingest entry consists\nof an offset (in offset form) to
    the next ingest entry, followed again\nby a length field and a slaw.
    The ingest offset is functionally\nidentical to the descrip offset,
    except that it points to the next\ningest entry rather than to the next
    descrip entry.\n\nIn most proteins, every ingest is of the slaw cons
    type (a two-value\nlist, generally used as a key/value pair). The slaw
    cons record\nconsists of a four-byte length/type header with the second
    most\nsignificant bit set and only the lower 30 bits used to specify
    length;\na four-byte offset to the start of the value (second) element;
    the\nfour-byte length of the key element; the slaw record for the key\nelement;
    the four-byte length of the value element; and finally the\nslaw record
    for the value element.\n\nGenerally, the cons key is a slaw string.
    The duplication of data\nacross the several protein and slaw cons length
    and offsets field\nprovides yet more opportunity for refinement and
    optimization.\n\n\n- Slawx -\n\nThe construct used to embed typed data
    inside proteins, as described\nabove, is a tagged byte-sequence specification
    and abstraction called\na \"slaw.\" (Plural: slawx.)\n\nA slaw is a
    linear sequence of bytes representing a piece of (possibly\naggregate)
    typed data, and is associated with\nprogramming-language-specific APIs
    that allow slawx to be created,\nmodified and moved around between memory
    spaces, storage media, and\nmachines. The slaw type scheme is intended
    to be extensible and as\nlightweight as possible, and to be a common
    substrate that can be\nused from any programming language.\n\nThe desire
    to build an efficient, large-scale inter-process\ncommunication mechanism
    is the driver of the slaw design. Modern\nprogramming languages provide
    sophisticated data structures and type\nfacilities that work beautifully
    in process-specific memory layouts,\nbut these data representations
    invariably break down when data needs\nto be moved between processes
    or stored on disk. The slaw architecture\nis, first, a substantially
    efficient, multi-platform friendly,\nlow-level data model for inter-process
    communication.\n\nBut even more importantly, slawx are designed to influence
    -- together\nwith proteins -- the development of future computing hardware\n(microprocessors,
    memory controllers, disk controllers). A few\nspecific additions to,
    say, the instruction sets of commonly available\nmicroprocessors would
    make it possible for slawx to become as\nefficient even for single-process,
    in-memory data layout as the schema\nused in most programming languages.\n\nEvery
    slaw consists of a variable-length type header followed by a\ntype-specific
    data layout. In the current implementation, which\nsupports full slaw
    functionality in C, C++ and Ruby, types are\nindicated by a universal
    integer defined in system header files\naccessible from each language.
    More sophisticated and flexible type\nresolution functionality is anticipated:
    for example, indirect typing\nvia universal object IDs and network lookup.\n\nBasic
    slaw functionality includes API facilities to\n\n - create a new slaw
    of a specific type\n - \"create\" (build a language-specific reference
    to) a slaw from\n   bytes on disk or in memory\n - embed data within
    a slaw in type-specific fashion\n - retrieve data from within a slaw\n
    - clone (shallow-copy) a slaw\n - copy (deep-copy) a slaw\n - translate
    the endianness of all data within a slaw\n\nEvery species of slaw is
    required to implement the above behaviors.\n\nOur slaw implementation
    allows slaw records to be used as objects in\nlanguage-friendly fashion
    from both Ruby and C++. A suite of utilities\nexternal to the C++ compiler
    sanity-check slaw byte layout, create\nheader files and macros specific
    to individual slaw types, and\nauto-generate bindings for Ruby. As a
    result, well-designed slaw types\nare quite efficient even when used
    from within a single process. Any\nslaw anywhere in a process's accessible
    memory can be addressed\nwithout a copy or \"deserialization\" step.\n\n\n-
    Pools -\n\nA \"pool\" is a repository for proteins, providing linear
    sequencing and\nstate caching; multi-process access; and a set of common,
    optimizable\nfiltering and pattern-matching behaviors.\n\nSlawx provide
    the lowest-level of data definition for inter-process\nexchange; proteins
    provide mid-level structure and hooks for querying\nand filtering; and
    pools provide for high-level organization and\naccess semantics.\n\nThe
    pools API is designed to allow pools to be implemented in a\nvariety
    of ways, in order to account both for system-specific goals\nand for
    the available capabilities of given hardware and network\narchitectures.
    The two fundamental system provisions upon which pools\ndepend are a
    storage facility and a means of inter-process\ncommunication. In our
    extant systems we use a flexible combination of\nshared memory, virtual
    memory, and disk for the former, and IPC queues\nand TCP/IP sockets
    for the latter.\n\nThe most basic pool functionality is as follows:\n\n
    - \"participate in\" a pool\n - put a protein in a pool\n - retrieve
    the next unseen protein from a pool\n - \"rewind\" or \"fast-forward\"
    within a pool\n\nA very simple pool implementation might provide only
    those four\nmethods. However, most real-world pools would also support
    (and\nencourage):\n\n - setting up a \"streaming\" pool call-back for
    a process\n - selectively retrieving proteins that match particular
    patterns of\n   descrips or ingests keys\n - scanning backward and forwards
    for proteins that match particular\n   patterns of descrips or ingests
    keys\n\nCritical to the design of the pools architecture is the conception
    of\npools as maintaining state, so that individual processes can offload\nmuch
    of the tedious bookkeeping common to multi-process program\ncode. A
    pool attempts to keep a large buffer of past proteins\navailable --
    the Platonic pool is explicitly infinite -- so that\nparticipating processes
    can scan both backwards and forwards in a pool\nat will. The size of
    the buffer is implentation dependent, of course,\nbut in common usage
    it is often possible to keep proteins in a pool\nfor hours or days.\n\nWith
    so much data available to potentially legion pool participants,\npool
    behavior optimization becomes important. We have implemented a\nnumber
    of optimized caching and storage schemes that make it possible\nto accomodate
    tens of thousands of proteins in a pool and, and we use\ncareful connection
    pooling on the unix operating system to handle\nhundreds of concurrent
    connections with relatively low overhead. As\nwith slawx, we expect
    eventually to implement many of these algorithms\nin hardware, leading
    to further efficiency and scalability.\n\nThe most common \"style\"
    of pool usage in our programs hews to a\nbiological metaphor, in contrast
    to the mechanistic, point-to-point\napproach taken by existing inter-process
    communication frameworks. The\nname \"protein\" alludes to bilological
    inspiration: data proteins in\npools are available for flexible querying
    and pattern matching by a\nlarge number of computational processes,
    as chemical proteins in a\nliving organism are available for pattern
    matching and filtering by\nlarge numbers of cellular agents.\n\nTwo
    additional abstractions (currently implemented in both\nC++ and Ruby)
    lean on the biological metaphor.\n\nA process that participates in a
    pool generally creates a number of\n\"handlers,\" small bundles of code
    that associate \"match conditions\"\nwith \"handle behaviors.\" By tying
    one or more handlers to a pool, a\nprocess sets up flexible call-back
    triggers that are trivially able to\nencapsulate state and react to
    new proteins.\n\nA process that participates in several pools generally
    inherits from\nan abstract \"Golgi\" class. The Golgi framework provides
    a number of\nuseful routines for managing multiple pools and handlers.
    The Golgi\nclass also encapsualates parent-child relationships, providing
    a\nmechanism for \"local\" protein exchange that does not use a\npool.\n\"\n
    6: slaw[xxx]: CONS:\n 6:  L: slaw[xxx]: STR(34): \"some non-ASCII text
    from Wikipedia\"\n 6:  R: slaw[xxx]: STR(750): \"There are three types
    of adjective:\n\n1)  keiyshi, or i adjectives, which have a conjugating
    ending i\n   () (such as  atsui \"to be hot\") which can become
    past (\n     atsukatta \"it was hot\"), or negative ( atsuku
    nai\n   \"it is not hot\"). Note that nai is also an i adjective, which
    can\n   become past ( atsuku nakatta \"it was not hot\").\n\n
    \      atsui hi \"a hot day\".\n\n2)  keiydshi, or na adjectives,
    which are followed by a form\n   of the copula, usually na. For example
    hen (strange)\n\n       hen na hito \"a strange person\".\n\n3)
     rentaishi, also called true adjectives, such as ano \"that\"\n\n
    \      ano yama \"that mountain\".\n\"\n 7: slaw[xxx]: CONS:\n 7:
    \ L: slaw[xxx]: STR(28): \"my six favorite unit vectors\"\n 7:  R: slaw[xxx]:
    V3INT8/A(6) = [(1, 0, 0) ; (0, 1, 0) ; (0, 0, 1) ; (-1, 0, 0) ; (0,
    -1, 0) ; (0, 0, -1)]\n 8: slaw[xxx]: CONS:\n 8:  L: slaw[xxx]: STR(7):
    \"pumpkin\"\n 8:  R: slaw[xxx]: FLOAT32 = 3.141593\n 9: slaw[xxx]: CONS:\n
    9:  L: slaw[xxx]: STR(5): \"pecan\"\n 9:  R: slaw[xxx]: FLOAT64 = 3.141593\n
    10: slaw[xxx]: CONS:\n 10:  L: slaw[xxx]: STR(15): \"keepin' it real\"\n
    10:  R: slaw[xxx]: UNT32C = 1 + j0\n 11: slaw[xxx]: CONS:\n 11:  L:
    slaw[xxx]: STR(28): \"now here's something complex\"\n 11:  R: slaw[xxx]:
    V4FLOAT64C = (1.200000 + j3.400000, 5.600000 + j7.800000, 9.000000 +
    j0.100000, 0.010000 + j3.141593)\n 12: slaw[xxx]: CONS:\n 12:  L: slaw[xxx]:
    STR(19): \"the largest integer\"\n 12:  R: slaw[xxx]: UNT64 = 18446744073709551615\n
    13: slaw[xxx]: CONS:\n 13:  L: slaw[xxx]: STR(20): \"the smallest integer\"\n
    13:  R: slaw[xxx]: INT64 = -9223372036854775808\n 14: slaw[xxx]: CONS:\n
    14:  L: slaw[xxx]: STR(20): \"some strange consing\"\n 14:  R: slaw[xxx]:
    CONS:\n 14:  R:  L: slaw[xxx]: LIST (5 elems): {\n 14:  R:  L:  1: slaw[xxx]:
    NIL.\n 14:  R:  L:  2: slaw[xxx]: NIL.\n 14:  R:  L:  3: slaw[xxx]:
    NIL.\n 14:  R:  L:  4: slaw[xxx]: NIL.\n 14:  R:  L:  5: slaw[xxx]:
    NIL.\n 14:  R:  L:  }\n 14:  R:  R: slaw[xxx]: CONS:\n 14:  R:  R:  L:
    slaw[xxx]: CONS:\n 14:  R:  R:  L:  L: slaw[xxx]: STR(1): \"a\"\n 14:
    \ R:  R:  L:  R: slaw[xxx]: STR(1): \"b\"\n 14:  R:  R:  R: slaw[xxx]:
    CONS:\n 14:  R:  R:  R:  L: slaw[xxx]: STR(1): \"c\"\n 14:  R:  R:  R:
    \ R: slaw[xxx]: STR(1): \"d\"\n 15: slaw[xxx]: CONS:\n 15:  L: slaw[xxx]:
    STR(13): \"an empty list\"\n 15:  R: slaw[xxx]: LIST (0 elems): {\n
    15:  R:  }\n 16: slaw[xxx]: CONS:\n 16:  L: slaw[xxx]: STR(1025): \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n
    16:  R: slaw[xxx]: STR(389): \"This key is longer than 1024 characters,
    to test out the fact that implicit keys cannot exceed 1024 characters,
    even if the key could otherwise be implicit.  See http://yaml.org/spec/1.2/#id2597711
    for more information.  So that means that we should see a '?' in front
    of this key.  It looks like libYaml adds the '?' for any key longer
    than 128 characters, even though the spec says 1024.\"\n 17: slaw[xxx]:
    CONS:\n 17:  L: slaw[xxx]: STR(1023): \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n
    17:  R: slaw[xxx]: UNT32 = 1023\n 18: slaw[xxx]: CONS:\n 18:  L: slaw[xxx]:
    STR(45): \"\U0002517D is outside the Basic Multilingual Plane.\"\n 18:
    \ R: slaw[xxx]: NIL.\n 19: slaw[xxx]: CONS:\n 19:  L: slaw[xxx]: STR(22):
    \"$      \"\n 19:  R: slaw[xxx]: STR(5): \"money\"\n 20: slaw[xxx]:
    CONS:\n 20:  L: slaw[xxx]: STR(22): \"0-length array of int8\"\n 20:
    \ R: slaw[xxx]: INT8/A(0) = []\n 21: slaw[xxx]: CONS:\n 21:  L: slaw[xxx]:
    STR(23): \"0-length array of unt64\"\n 21:  R: slaw[xxx]: UNT64/A(0)
    = []\n 22: slaw[xxx]: CONS:\n 22:  L: slaw[xxx]: STR(25): \"0-length
    array of complex\"\n 22:  R: slaw[xxx]: FLOAT32C/A(0) = []\n 23: slaw[xxx]:
    CONS:\n 23:  L: slaw[xxx]: STR(27): \"0-length array of 2-vectors\"\n
    23:  R: slaw[xxx]: V2FLOAT64/A(0) = []\n 24: slaw[xxx]: CONS:\n 24:
    \ L: slaw[xxx]: STR(27): \"0-length array of 3-vectors\"\n 24:  R: slaw[xxx]:
    V3UNT8/A(0) = []\n 25: slaw[xxx]: CONS:\n 25:  L: slaw[xxx]: STR(27):
    \"0-length array of 4-vectors\"\n 25:  R: slaw[xxx]: V4FLOAT32/A(0)
    = []\n 26: slaw[xxx]: CONS:\n 26:  L: slaw[xxx]: STR(33): \"0-length
    array of complex vectors\"\n 26:  R: slaw[xxx]: V4INT16C/A(0) = []\n
    27: slaw[xxx]: CONS:\n 27:  L: slaw[xxx]: STR(22): \"1-length array
    of int8\"\n 27:  R: slaw[xxx]: INT8/A(1) = [0]\n 28: slaw[xxx]: CONS:\n
    28:  L: slaw[xxx]: STR(23): \"1-length array of unt64\"\n 28:  R: slaw[xxx]:
    UNT64/A(1) = [0]\n 29: slaw[xxx]: CONS:\n 29:  L: slaw[xxx]: STR(25):
    \"1-length array of complex\"\n 29:  R: slaw[xxx]: FLOAT32C/A(1) = [0.000000
    + j0.000000]\n 30: slaw[xxx]: CONS:\n 30:  L: slaw[xxx]: STR(27): \"1-length
    array of 2-vectors\"\n 30:  R: slaw[xxx]: V2FLOAT64/A(1) = [(0.000000,
    0.000000)]\n 31: slaw[xxx]: CONS:\n 31:  L: slaw[xxx]: STR(27): \"1-length
    array of 3-vectors\"\n 31:  R: slaw[xxx]: V3UNT8/A(1) = [(0, 0, 0)]\n
    32: slaw[xxx]: CONS:\n 32:  L: slaw[xxx]: STR(27): \"1-length array
    of 4-vectors\"\n 32:  R: slaw[xxx]: V4FLOAT32/A(1) = [(0.000000, 0.000000,
    0.000000, 0.000000)]\n 33: slaw[xxx]: CONS:\n 33:  L: slaw[xxx]: STR(33):
    \"1-length array of complex vectors\"\n 33:  R: slaw[xxx]: V4INT16C/A(1)
    = [(0 + j0, 0 + j0, 0 + j0, 0 + j0)]\n 34: slaw[xxx]: CONS:\n 34:  L:
    slaw[xxx]: STR(14): \"a map of stuff\"\n 34:  R: slaw[xxx]: MAP (5 elems):
    {\n 34:  R:  1: slaw[xxx]: CONS:\n 34:  R:  1:  L: slaw[xxx]: STR(5):
    \"false\"\n 34:  R:  1:  R: slaw[xxx]: BOOLEAN: false\n 34:  R:  2:
    slaw[xxx]: CONS:\n 34:  R:  2:  L: slaw[xxx]: STR(41): \"protein with
    neither descrips nor ingests\"\n 34:  R:  2:  R: slaw[xxx]: PROT: ((\n
    34:  R:  2:  R:  ))\n 34:  R:  3: slaw[xxx]: CONS:\n 34:  R:  3:
    \ L: slaw[xxx]: STR(24): \"protein with no descrips\"\n 34:  R:  3:
    \ R: slaw[xxx]: PROT: ((\n 34:  R:  3:  R: ingests:\n 34:  R:  3:  R:
    slaw[xxx]: FLOAT64 = 3.141590\n 34:  R:  3:  R:  ))\n 34:  R:  4: slaw[xxx]:
    CONS:\n 34:  R:  4:  L: slaw[xxx]: STR(23): \"protein with no ingests\"\n
    34:  R:  4:  R: slaw[xxx]: PROT: ((\n 34:  R:  4:  R: descrips:\n 34:
    \ R:  4:  R: slaw[xxx]: UNT32 = 83880052\n 34:  R:  4:  R:  ))\n 34:
    \ R:  5: slaw[xxx]: CONS:\n 34:  R:  5:  L: slaw[xxx]: STR(4): \"true\"\n
    34:  R:  5:  R: slaw[xxx]: BOOLEAN: true\n 34:  R:  }\n 35: slaw[xxx]:
    CONS:\n 35:  L: slaw[xxx]: STR(19): \"HorriblyNestedLists\"\n 35:  R:
    slaw[xxx]: LIST (3 elems): {\n 35:  R:  1: slaw[xxx]: LIST (3 elems):
    {\n 35:  R:  1:  1: slaw[xxx]: LIST (3 elems): {\n 35:  R:  1:  1:  1:
    slaw[xxx]: FLOAT64/A(0) = []\n 35:  R:  1:  1:  2: slaw[xxx]: FLOAT64/A(1)
    = [2.000000]\n 35:  R:  1:  1:  3: slaw[xxx]: FLOAT64/A(2) = [1.414214
    ; 1.189207]\n 35:  R:  1:  1:  }\n 35:  R:  1:  2: slaw[xxx]: LIST (3
    elems): {\n 35:  R:  1:  2:  1: slaw[xxx]: FLOAT64/A(3) = [1.090508
    ; 1.044274 ; 1.021897]\n 35:  R:  1:  2:  2: slaw[xxx]: FLOAT64/A(4)
    = [1.010889 ; 1.005430 ; 1.002711 ; 1.001355]\n 35:  R:  1:  2:  3:
    slaw[xxx]: FLOAT64/A(5) = [1.000677 ; 1.000339 ; 1.000169 ; 1.000085
    ; 1.000042]\n 35:  R:  1:  2:  }\n 35:  R:  1:  3: slaw[xxx]: LIST (3
    elems): {\n 35:  R:  1:  3:  1: slaw[xxx]: FLOAT64/A(6) = [1.000021
    ; 1.000011 ; 1.000005 ; 1.000003 ; 1.000001 ; 1.000001]\n 35:  R:  1:
    \ 3:  2: slaw[xxx]: FLOAT64/A(7) = [1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n 35:  R:  1:  3:  3: slaw[xxx]:
    FLOAT64/A(8) = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000]\n 35:  R:  1:  3:  }\n 35:  R:  1:
    \ }\n 35:  R:  2: slaw[xxx]: LIST (3 elems): {\n 35:  R:  2:  1: slaw[xxx]:
    LIST (3 elems): {\n 35:  R:  2:  1:  1: slaw[xxx]: FLOAT64/A(9) = [1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000]\n 35:  R:  2:  1:  2: slaw[xxx]: FLOAT64/A(10)
    = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n 35:  R:  2:  1:  3: slaw[xxx]:
    FLOAT64/A(11) = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n
    35:  R:  2:  1:  }\n 35:  R:  2:  2: slaw[xxx]: LIST (3 elems): {\n
    35:  R:  2:  2:  1: slaw[xxx]: FLOAT64/A(12) = [1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n 35:  R:  2:  2:  2: slaw[xxx]:
    FLOAT64/A(13) = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000]\n 35:  R:  2:  2:  3: slaw[xxx]: FLOAT64/A(14)
    = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000]\n 35:  R:  2:  2:  }\n 35:  R:  2:  3: slaw[xxx]: LIST (3
    elems): {\n 35:  R:  2:  3:  1: slaw[xxx]: FLOAT64/A(15) = [1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000]\n 35:  R:  2:  3:  2: slaw[xxx]: FLOAT64/A(16) = [1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000]\n 35:  R:  2:  3:  3: slaw[xxx]: FLOAT64/A(17)
    = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n 35:  R:  2:  3:  }\n
    35:  R:  2:  }\n 35:  R:  3: slaw[xxx]: LIST (3 elems): {\n 35:  R:
    \ 3:  1: slaw[xxx]: LIST (3 elems): {\n 35:  R:  3:  1:  1: slaw[xxx]:
    FLOAT64/A(18) = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n
    35:  R:  3:  1:  2: slaw[xxx]: FLOAT64/A(19) = [1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n 35:  R:  3:  1:  3: slaw[xxx]:
    FLOAT64/A(20) = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000]\n 35:  R:  3:  1:  }\n 35:  R:  3:  2: slaw[xxx]:
    LIST (3 elems): {\n 35:  R:  3:  2:  1: slaw[xxx]: FLOAT64/A(21) = [1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000]\n 35:  R:  3:  2:  2: slaw[xxx]: FLOAT64/A(22) = [1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000]\n 35:  R:  3:  2:  3: slaw[xxx]: FLOAT64/A(23)
    = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n 35:  R:  3:  2:  }\n 35:
    \ R:  3:  3: slaw[xxx]: LIST (3 elems): {\n 35:  R:  3:  3:  1: slaw[xxx]:
    FLOAT64/A(24) = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n
    35:  R:  3:  3:  2: slaw[xxx]: FLOAT64/A(25) = [1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000]\n 35:  R:  3:  3:  3: slaw[xxx]:
    FLOAT64/A(26) = [1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000
    ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ; 1.000000 ;
    1.000000 ; 1.000000]\n 35:  R:  3:  3:  }\n 35:  R:  3:  }\n 35:  R:
    \ }\n }\nrude data: 913 bytes\n 42 5a 68 39 31 41 59 26 53 59 58 1f
    5a 35 00 00\n 4f ff 80 7f fe c2 00 40 f7 7f d8 10 02 08 00 3f\n ff ff
    f0 50 03 b8 33 3d 77 5d 57 4e b6 b0 34 d2\n 13 4c 29 9a 46 93 4d a8
    f5 06 80 06 83 43 40 00\n d0 99 04 c8 05 32 1a 68 06 80 1a 68 01 a6
    40 24\n 44 4d 29 e9 31 3d 32 21 32 34 d0 0d 06 26 83 35\n 1a 68 1c c0
    26 00 4c 00 02 60 00 26 00 02 53 4a\n 34 a7 a0 4f 4d 41 b4 43 43 04
    62 1e 80 98 4c 09\n df e5 97 32 4b 56 f8 0a d5 43 1d 66 54 94 a4 92\n
    88 83 f2 ea c6 d0 9b 1d 00 88 02 61 24 a8 92 b9\n 72 f0 f9 5f 0b a1
    c3 f7 95 82 8e e0 b7 a2 3b 69\n 15 be 0e da c3 75 63 6d 36 0f c6 d3
    2d 36 5e 00\n 2c 04 29 6d 9d d7 db fb 4b 8b 2d 0d 8c 32 0d 7a\n 55 69
    c5 04 01 8e 56 ce b7 81 72 11 48 80 60 e9\n b6 05 32 c9 66 13 69 bb
    67 f3 5e 02 08 7f 72 33\n 8e 39 a2 72 fc 9c ed 2e fd f7 6e d1 5e e8
    aa ce\n 1b 11 ba ec f1 d3 a6 f7 86 15 b9 d4 3a 5d 3f 74\n 88 73 43 68
    3d 76 c7 92 97 8f 2c 6e a3 e9 23 aa\n 28 24 8d 62 82 b8 d0 de 99 05
    74 9b ef 6d 0e 0b\n 85 11 f8 34 8c 50 e4 40 ad d7 5c e2 a7 f3 7b e6\n
    e9 08 83 7c 43 26 68 32 c5 d9 a1 12 c5 21 d7 58\n 56 1a aa d5 11 65
    4b 05 b9 94 01 11 26 ec e2 20\n 36 4f 1c c3 f3 0d 40 7b c3 d9 f8 09
    de b8 b2 dd\n 22 d1 84 a0 1d 2a 56 4e e4 76 d9 8a 05 53 1b 0c\n 13 b0
    81 81 20 60 fc fb cb 4d 2e 1d d9 51 a4 a8\n 0f 9d 0d e6 40 1b 27 8e
    b5 0c d7 58 f0 40 eb 36\n 09 68 f1 29 5e d0 1e d6 51 90 c9 64 da ea
    98 54\n 20 5d 50 9d 1b 98 ae ce 52 18 35 ca 1e a2 3c 02\n 02 d2 6f 08
    85 e0 d7 3f b7 d3 d2 3e a1 ca 4e 17\n 74 f3 e8 93 0d 41 54 1f 68 d4
    9f 83 06 7a f6 6c\n ee d9 89 40 c8 7c 81 61 1b ab 52 1c 6c 8a c0 75\n
    be c3 8b 8f 76 e5 4e cb 91 da c3 58 d9 2b bc 68\n 6d b0 93 43 46 43
    83 d0 e8 1d 39 34 18 8c 94 2a\n a0 f2 ae 88 9e 59 67 44 d1 c6 74 ec
    24 69 0e b2\n ca c4 8c 65 e5 2d bc d5 14 58 ce 0a 78 08 de 83\n 51 8e
    3a 95 d4 d7 ad a0 d1 39 f4 50 68 c1 ac 9d\n b0 a9 31 24 c5 0f 58 ad
    5d 5a f1 17 37 78 a8 53\n a6 41 20 40 10 9a 38 52 46 4f 9c 1d cd 9a
    50 ab\n 54 4a e3 0c 5c 1c 18 49 c9 7a b8 cf 02 76 df 00\n 2e 29 72 64
    bd 82 6a 90 90 0d 20 cd e8 16 d7 de\n 03 12 45 b3 54 bd 06 61 f1 16
    c4 8a e2 ae 80 a8\n de 88 05 b2 a7 53 2a 5d 54 5a d3 b4 6c ac 44 83\n
    22 88 61 1c 35 d3 2a 8c b9 11 6b 61 68 a2 a3 ab\n 76 6c 2a c1 b4 7c
    5d f6 c6 bb 77 46 2e 3b 9d 13\n bc 36 7a 84 91 a1 6a 26 55 20 cb 10
    60 2b 8a 67\n 37 54 59 60 72 17 48 57 1c bd 74 5a e5 1b c0 25\n a4 ba
    da 4b 2d 25 04 0c c1 43 cd 9b 66 49 1b 54\n 43 8c 5b 6a 36 ad 39 dc
    02 5e 8a a3 33 52 20 68\n 43 b4 8a 2e b9 3a b8 e4 d0 52 d2 2c 6d 1c
    a1 60\n f8 64 6c fd 4b 2c d5 03 9a 94 cd 50 6e 19 50 66\n 40 ac b3 91
    87 31 17 01 e2 70 e2 79 36 ef 10 a3\n 2b 44 9a 2b 57 d0 0a 90 dd 89
    62 a2 99 04 fd 29\n 64 d4 0a 4f 76 4d a8 e0 aa 16 4d 13 0f 9c 5c c1\n
    64 83 72 28 6a d9 4f f4 ed 59 dc ba 00 66 2e 8f\n 83 2b 1b 84 20 f9
    31 36 86 eb b1 42 04 12 d0 c6\n d9 2d 24 94 24 74 b5 29 a6 9a 1a 10
    b3 5a b9 30\n 98 6f cc 8c c2 e3 fe 2e e4 8a 70 a1 20 b0 3e b4\n 6a\n
    ))"
...
